#!/usr/bin/env python3

import lark

class Term:
    def __str__(self):
        return self._str(False, False)

    def _rolllambda(self, l):
        return self

class Var(Term):
    def __init__(self, name):
        self.name = name

    def _str(self, bracketa, bracketl):
        return self.name

class Apply(Term):
    def __init__(self, a, b):
        self.a = a
        self.b = b

    def _str(self, bracketa, bracketl):
        if bracketa:
            return f"({self._str(False, False)})"
        return f"{self.a._str(False, True)} {self.b._str(True, bracketl)}"

class Lambda(Term):
    def __init__(self, v, e):
        self.v = v
        self.e = e

    def _rolllambda(self, vars):
        vars.append(self.v)
        return self.e._rolllambda(vars)

    def _str(self, bracketa, bracketl):
        if bracketl:
            return f"({self._str(False, False)})"
        vars = []
        e = self._rolllambda(vars)
        return f"Î»{' '.join(vars)}. {e._str(False, False)}"

@lark.v_args(inline=True)
class Transformer(lark.Transformer):
    def var(self, v):
        return Var(v)

    def apply(self, a, b):
        return Apply(a, b)

    def varlist(self, *args):
        return args

    def mlambda(self, vars, e):
        res = e
        for v in reversed(vars):
            res = Lambda(v, res)
        return res

    #def mlambda(self, *args):
    #    print(repr(args))


def main(top):
    with (top / "grammar.lark").open() as f:
        parser = lark.Lark(f.read(), parser='lalr')
    transf = Transformer()
    testfiles = top / "testfiles"
    for tf in testfiles.iterdir():
        print(f"==== {tf}")
        parse = parser.parse(tf.read_text())
        print(parse.pretty())
        parse = transf.transform(parse)
        print(parse.pretty())

if __name__ == '__main__':
    import pathlib
    main(pathlib.Path(__file__).parent)
